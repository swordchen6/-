基于c语言pthread，C++的封装思想的线程池。
线程池的基本思想
线程池是先开辟多个线程，形象的称为把线程放到线程池去管理。
为什么要有线程池？
1.线程的重复开辟对系统来说开销很高。
2.如果对于每个使用的线程没有进行合格的管理，每个线程创建后我们将不知道线程的去向。

线程池在工作上分三部分
1.任务队列
保存着一些需要完成的小任务，和线程池形成一个消费者和生产者模型。
因为使用的是C++STL的queue容器来实现的任务队列，因此可以将任务队列满的情况排除。
因此，当任务队列有任务进来时，我们需要通知线程池来处理任务。

2.工作线程
在没有任务的时候需要保证工作线程能够阻塞等待任务。
在有任务的时候需要根据线程同步去实现任务。
另外，为了让线程池在任务很少的时候，我们终止一些空闲的线程，当然保证终止后的线程数大于最小线程数。
这个部分是最难实现的，是通过管理线程通知线程有任务了，然后诈骗工作线程自杀。
对于从外部线程终止另外一个线程的方法有三种：
  1.从主线程return，在这种情况下，线程池的所有线程将一起终止，显然不合理
  2.调用exit函数，同上不合理
  3.pthread_cancel为什么很少人使用?
我总结的原因有以下三种：
  （1）pthread_cancel函数首先需要终止线程进入一个取消点，这个取消点通常是在一些系统调用中，当然也可使用pthread_testcancel自行设置取消点。
      但可能想要终止的线程没有调用系统函数，或者阻塞在一个地方，因此pthread_cancel函数根本无效，另外强行使用pthread_testcancel会产生不必要的消耗。
      因为这根本不是我们想要执行的核心代码，而且该函数也不并能满足实际情况的需要。
  （2）pthread_cancel函数对于异常的处理也不足够，当一个线程在加锁后，这时就算pthread_cancel函数调用成功，但由于没有解锁，程序很有可能发生死锁。
  （3）另外，由于pthread_cancel函数调用成功，剩下的代码没有执行，也有可能将程序的数据带来污染，产生脏数据。

3.管理线程
当任务少时，终止一些线程，减少系统资源消耗。
当任务多时，能够创建线程，来缓解线程池的压力。
